From 9fe2a7b984e3b008bbb1605eb33f7937d43cf018 Mon Sep 17 00:00:00 2001
From: "Allen.Ye" <allen.ye@mediatek.com>
Date: Wed, 17 Aug 2022 09:55:10 +0800
Subject: [PATCH] HAL: add get and set guard interval functions

---
 source/wifi/wifi_hal.c | 132 +++++++++++++++++++++++++++++++++++++++--
 1 file changed, 128 insertions(+), 4 deletions(-)

diff --git a/source/wifi/wifi_hal.c b/source/wifi/wifi_hal.c
index dd5e8d4..19aa67e 100644
--- a/source/wifi/wifi_hal.c
+++ b/source/wifi/wifi_hal.c
@@ -74,6 +74,7 @@ Licensed under the ISC license
 #define SOCK_PREFIX "/var/run/hostapd/wifi"
 #define VAP_STATUS_FILE "/tmp/vap-status"
 #define ESSID_FILE "/tmp/essid"
+#define GUARD_INTERVAL_FILE "/tmp/guard-interval"
 
 #ifdef MTK_IMPL
 #define DRIVER_2GHZ "mt7915e"
@@ -2409,18 +2410,53 @@ INT wifi_setRadioExtChannel(INT radioIndex, CHAR *string) //Tr181	//AP only
 //The output_string is a max length 64 octet string that is allocated by the RDKB code.  Implementations must ensure that strings are not longer than this.
 INT wifi_getRadioGuardInterval(INT radioIndex, CHAR *output_string)	//Tr181
 {
-    //save config and apply instantly
-    if (NULL == output_string)
+    wifi_guard_interval_t GI;
+
+    WIFI_ENTRY_EXIT_DEBUG("Inside %s:%d\n",__func__, __LINE__);
+
+    if (output_string == NULL || wifi_getGuardInterval(radioIndex, &GI) == RETURN_ERR)
         return RETURN_ERR;
-    snprintf(output_string, 64, "Auto");
 
+    if (GI == wifi_guard_interval_400)
+        strcpy(output_string, "400nsec");
+    else if (GI == wifi_guard_interval_800)
+        strcpy(output_string, "800nsec");
+    else if (GI == wifi_guard_interval_1600)
+        strcpy(output_string, "1600nsec");
+    else if (GI == wifi_guard_interval_3200)
+        strcpy(output_string, "3200nsec");
+    else
+        strcpy(output_string, "auto");
+
+    WIFI_ENTRY_EXIT_DEBUG("Exiting %s:%d\n",__func__, __LINE__);
     return RETURN_OK;
 }
 
 //Set the guard interval value.
 INT wifi_setRadioGuardInterval(INT radioIndex, CHAR *string)	//Tr181
 {
-    //Apply setting instantly
+    wifi_guard_interval_t GI;
+    int ret = 0;
+
+    WIFI_ENTRY_EXIT_DEBUG("Inside %s:%d\n",__func__, __LINE__);
+
+    if (strcmp(string, "400nsec") == 0)
+        GI = wifi_guard_interval_400;
+    else if (strcmp(string , "800nsec") == 0 || strcmp(string, "auto") == 0)
+        GI = wifi_guard_interval_800;
+    else if (strcmp(string , "1600nsec") == 0)
+        GI = wifi_guard_interval_1600;
+    else if (strcmp(string , "3200nsec") == 0)
+        GI = wifi_guard_interval_3200;
+
+    ret = wifi_setGuardInterval(radioIndex, GI);
+
+    if (ret == RETURN_ERR) {
+        wifi_dbg_printf("%s: wifi_setGuardInterval return error\n", __func__);
+        return RETURN_ERR;
+    }
+
+    WIFI_ENTRY_EXIT_DEBUG("Exiting %s:%d\n",__func__, __LINE__);
     return RETURN_OK;
 }
 
@@ -9456,6 +9492,94 @@ INT wifi_isZeroDFSSupported(UINT radioIndex, BOOL *supported)
      return RETURN_OK;
 }
 
+INT wifi_setGuardInterval(INT radio_index, wifi_guard_interval_t guard_interval)
+{
+    char cmd[128] = {0};
+    char buf[64] = {0};
+    char band_str[8] = {0};
+    char GI[8] = {0};
+    int tmp = 0;
+    BOOL ax_mode = FALSE;
+    BOOL short_GI = FALSE;
+    FILE *f = NULL;
+    wifi_band band;
+
+    WIFI_ENTRY_EXIT_DEBUG("Inside %s:%d\n",__func__, __LINE__);
+
+    if (wifi_getRadioMode(radio_index, buf, &tmp) == RETURN_ERR) {
+        wifi_dbg_printf("%s: wifi_getRadioMode return error\n", __func__);
+        return RETURN_ERR;
+    }
+    if (strstr(buf, "ax") != NULL)
+        ax_mode = TRUE;
+
+    if (guard_interval == wifi_guard_interval_400 && ax_mode != TRUE) {
+        short_GI = TRUE;
+        strcpy(GI, "0.4");
+    } else if (guard_interval == wifi_guard_interval_1600 && ax_mode == TRUE)
+        strcpy(GI, "1.6");
+    else if (guard_interval == wifi_guard_interval_3200 && ax_mode == TRUE)
+        strcpy(GI, "3.2");
+    else        // default
+        strcpy(GI, "0.8");
+
+    band = wifi_index_to_band(radio_index);
+    if (band == band_2_4)
+        strcpy(band_str, "2.4");
+    else if (band == band_5)
+        strcpy(band_str, "5");
+    else if (band == band_6)
+        strcpy(band_str, "6");
+    else {
+        wifi_dbg_printf("%s: invalid band\n");
+        return RETURN_ERR;
+    }
+
+    if (ax_mode == TRUE)
+        snprintf(cmd, sizeof(cmd), "iw dev %s%d set bitrates he-gi-%s %s", AP_PREFIX, radio_index, band_str, GI);
+    else
+        snprintf(cmd, sizeof(cmd), "iw dev %s%d set bitrates %sgi-%s", AP_PREFIX, radio_index, (short_GI)?"s":"l", band_str);
+    _syscmd(cmd, buf, sizeof(buf));
+
+    // Record GI for get GI function
+    snprintf(buf, sizeof(buf), "%s%d.txt", GUARD_INTERVAL_FILE, radio_index);
+    f = fopen(buf, "w");
+    if (f != NULL) {
+        fprintf(f, "%s", GI);
+    }
+    fclose(f);
+    WIFI_ENTRY_EXIT_DEBUG("Exiting %s:%d\n",__func__, __LINE__);
+    return RETURN_OK;
+}
+
+INT wifi_getGuardInterval(INT radio_index, wifi_guard_interval_t *guard_interval)
+{
+    char buf[32] = {0};
+    char cmd[64] = {0};
+
+    WIFI_ENTRY_EXIT_DEBUG("Inside %s:%d\n",__func__, __LINE__);
+
+    if (guard_interval == NULL)
+        return RETURN_ERR;
+
+    snprintf(cmd, sizeof(cmd), "cat %s%d.txt", GUARD_INTERVAL_FILE, radio_index);
+    _syscmd(cmd, buf, sizeof(buf));
+
+    if (strcmp(buf, "0.4") == 0)
+        *guard_interval = wifi_guard_interval_400;
+    else if (strcmp(buf, "0.8") == 0)
+        *guard_interval = wifi_guard_interval_800;
+    else if (strcmp(buf, "1.6") == 0)
+        *guard_interval = wifi_guard_interval_1600;
+    else if (strcmp(buf, "3.2") == 0)
+        *guard_interval = wifi_guard_interval_3200;
+    else
+        *guard_interval = wifi_guard_interval_auto;
+
+    WIFI_ENTRY_EXIT_DEBUG("Exiting %s:%d\n",__func__, __LINE__);
+    return RETURN_OK;
+}
+
 /* multi-psk support */
 INT wifi_getMultiPskClientKey(INT apIndex, mac_address_t mac, wifi_key_multi_psk_t *key)
 {
-- 
2.18.0

