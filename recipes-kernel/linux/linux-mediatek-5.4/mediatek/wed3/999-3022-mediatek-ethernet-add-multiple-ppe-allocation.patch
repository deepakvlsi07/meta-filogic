From 9c849a6e5a246489c5c91565d4c89a32958cad29 Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Thu, 16 Nov 2023 11:21:53 +0800
Subject: [PATCH] 999-3022-mediatek-ethernet-add-multiple-ppe-allocation

---
 arch/arm64/boot/dts/mediatek/mt7988.dtsi        |  1 +
 drivers/net/ethernet/mediatek/mtk_eth_soc.c     | 10 +++++++++-
 drivers/net/ethernet/mediatek/mtk_eth_soc.h     |  2 ++
 drivers/net/ethernet/mediatek/mtk_ppe_offload.c | 10 ++++++++++
 4 files changed, 22 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/mediatek/mt7988.dtsi b/arch/arm64/boot/dts/mediatek/mt7988.dtsi
index 8d83f6b..d378a65 100644
--- a/arch/arm64/boot/dts/mediatek/mt7988.dtsi
+++ b/arch/arm64/boot/dts/mediatek/mt7988.dtsi
@@ -950,6 +950,7 @@
 		mediatek,infracfg = <&topmisc>;
 		mediatek,toprgu = <&watchdog>;
 		mediatek,hwver = <&hwver>;
+		mtketh-ppe-num = <3>;
 		#reset-cells = <1>;
 		#address-cells = <1>;
 		#size-cells = <0>;
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
index de2eac4..55d05fd 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -3669,7 +3669,14 @@ static int mtk_open(struct net_device *dev)
 			     SGMSYS_QPHY_PWR_STATE_CTRL, 0);
 
 	if (eth->soc->offload_version) {
-			gdm_config = MTK_GDMA_TO_PPE0;
+#if defined(CONFIG_MEDIATEK_NETSYS_V2) || defined(CONFIG_MEDIATEK_NETSYS_V3)
+			if (eth->ppe_num >= 3 && mac->id == 2)
+				gdm_config = MTK_GDMA_TO_PPE2;
+			else if (eth->ppe_num >=2 && mac->id == 1)
+				gdm_config = MTK_GDMA_TO_PPE1;
+			else
+#endif
+				gdm_config = MTK_GDMA_TO_PPE0;
 
 			for (i = 0; i < eth->ppe_num; i++)
 				mtk_ppe_start(eth->ppe[i]);
@@ -4635,6 +4642,7 @@ static const struct net_device_ops mtk_netdev_ops = {
 	.ndo_poll_controller	= mtk_poll_controller,
 #endif
 	.ndo_setup_tc		= mtk_eth_setup_tc,
+	.ndo_fill_receive_path	= mtk_eth_fill_receive_path,
 };
 
 static void mux_poll(struct work_struct *work)
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.h b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
index 50024a2..e0dfc9d 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -2041,6 +2041,8 @@ int mtk_eth_setup_tc(struct net_device *dev, enum tc_setup_type type,
 		     void *type_data);
 int mtk_eth_setup_tc_block(struct net_device *dev, struct flow_block_offload *f,
 			   struct mtk_eth *eth);
+int mtk_eth_fill_receive_path(struct net_device_path_ctx *ctx,
+			      struct net_device_path *path);
 void mtk_eth_set_dma_device(struct mtk_eth *eth, struct device *dma_dev);
 u32 mtk_rss_indr_table(struct mtk_rss_params *rss_params, int index);
 
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
index eab9e9d..e5ff575 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
@@ -694,6 +694,16 @@ int mtk_eth_setup_tc(struct net_device *dev, enum tc_setup_type type,
 	}
 }
 
+int mtk_eth_fill_receive_path(struct net_device_path_ctx *ctx,
+			      struct net_device_path *path)
+{
+	struct mtk_mac *mac = netdev_priv(ctx->dev);
+
+	path->mtk_wdma.wdma_idx = mac->id;
+
+	return 0;
+}
+
 int mtk_eth_offload_init(struct mtk_eth *eth, int id)
 {
 	if (!eth->ppe[id] || !eth->ppe[id]->foe_table)
-- 
2.18.0

